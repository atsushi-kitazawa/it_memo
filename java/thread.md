# スレッドダンプの取得、読み方について

## スレッドとは
    本来の定義はちょっと複雑で今回からの趣旨から外れるので割愛。
    かんたんに言うとプロセスがCPUを利用する単位のこと。
    スレッドを利用することでプロセスは非同期処理を実現することができる。
    pthread を利用して生成されるもののことを言う。
    「マルチスレッド」とはプロセス内で複数のスレッドが動作させること、することを指す。

## 非同期処理
    複数の処理(スレッド)を並列(シングルプロセッサの場合は見かけ上となり並列)に実行すること。
    世の中のほとんどのプロセスは非同期処理できるようにマルチスレッドで動作する。

    例) Webサーバ
    Webサーバは複数ユーザのリクエストをさばくことが主要な役割。
    仮にシングルスレッドで動作していると Aさんのリクエストをさばく間は Bさんのリクエストはさばけない(Bさんは待たされる)ことになる。
    なので、マルチスレッドで動作させ、Aさんのリクエストをさばいている間でも Bさんのリクエストをさばけるようにしている。

## JVMのmainスレッド
    JavaVM(JVM)もマルチスレッドで動作している。
    代表的なスレッドとして
    ・mainスレッド
    ・コンパイラスレッド
    ・GCスレッド
    がある。

    普通にプログラムした場合、自身の書いたコードは「main」スレッドのみで処理される。
    見かけ上はシングルスレッドで動作する。自身のコードをマルチスレッドで動作させるためには、専用のAPIを利用する必要がある。

## スレッドの生成方法
    Java ではスレッドを生成するためのさまざまな API が用意されているが、最も原始的な API は以下のふたつ。
    ・Thread クラス
    ・Runnable インタフェース
    ※ Thread クラスは Runnable インタフェースの実装クラス

    上記をそのまま利用するシーンは実際の開発ではあまり多くない。
    Executor インタフェースなどを利用する。
    [Executor (Java Platform SE 8 )](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/Executor.html)

    ※ Thread や Runnable を利用するとスレッドのライフサイクル管理が面倒(生成して、終了してというのを自身で管理する必要がある)
    Executor を利用するとそのあたりやってくれる。また、スレッドをプールしておいてくれる。
 
## スレッドダンプの取得方法
    1. kill -3 シグナルを送信する
	「kill -3 <pid>」
	※ JDK がインストールされていない環境で利用可
    2. jstack を利用する
	「jstack <pid>」
    3. jcmd Thread.print を利用する
	「jcmd <pid> Thread.print」

    以下はスレッドダンプではないが、スレッドの実行状態が確認できる。
    自身の環境などではこちらのほうが便利。

    4. jconsole を利用する
	JMX を有効にする必要がある。
    5. jvisualvm を利用する
	上記と同様 JMX を有効にする必要がある。

    JMX を有効にする方法。以下のシステムプロパティを指定して JVM を起動する。
	「-Dcom.sun.management.jmxremote=true
        　-Dcom.sun.management.jmxremote.port=7000
          -Dcom.sun.management.jmxremote.ssl=false
          -Dcom.sun.management.jmxremote.authenticate=false」

## スレッドダンプの読み方
## どのようなトラブルの調査に利用するのか
## jconsole上でスレッドを確認する
