# スレッドダンプの取得、読み方について

## スレッドとは
    本来の定義はちょっと複雑で今回からの趣旨から外れるので割愛。
    かんたんに言うとプロセスがCPUを利用する単位のこと。
    スレッドを利用することでプロセスは非同期処理を実現することができる。
    pthread を利用して生成されるもののことを言う。
    「マルチスレッド」とはプロセス内で複数のスレッドが動作させること、することを指す。

## 非同期処理
    複数の処理(スレッド)を並列(シングルプロセッサの場合は見かけ上となり並列)に実行すること。
    世の中のほとんどのプロセスは非同期処理できるようにマルチスレッドで動作する。

    例) Webサーバ
    Webサーバは複数ユーザのリクエストをさばくことが主要な役割。
    仮にシングルスレッドで動作していると Aさんのリクエストをさばく間は Bさんのリクエストはさばけない(Bさんは待たされる)ことになる。
    なので、マルチスレッドで動作させ、Aさんのリクエストをさばいている間でも Bさんのリクエストをさばけるようにしている。

## JVMのmainスレッド
    JavaVM(JVM)もマルチスレッドで動作している。
    代表的なスレッドとして
    ・mainスレッド
    ・コンパイラスレッド
    ・GCスレッド
    がある。

    普通にプログラムした場合、自身の書いたコードは「main」スレッドのみで処理される。
    見かけ上はシングルスレッドで動作する。自身のコードをマルチスレッドで動作させるためには、専用のAPIを利用する必要がある。

## スレッドの生成方法
    Java ではスレッドを生成するためのさまざまな API が用意されているが、最も原始的な API は以下のふたつ。
    ・Thread クラス
    ・Runnable インタフェース
    ※ Thread クラスは Runnable インタフェースの実装クラス

    上記をそのまま利用するシーンは実際の開発ではあまり多くない。
    Executor インタフェースなどを利用する。
    [Executor (Java Platform SE 8 )](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/Executor.html)

    ※ Thread や Runnable を利用するとスレッドのライフサイクル管理が面倒(生成して、終了してというのを自身で管理する必要がある)
    Executor を利用するとそのあたりやってくれる。また、スレッドをプールしておいてくれる。
 
## スレッドダンプの取得方法
    1. kill -3 シグナルを送信する
	「kill -3 <pid>」
	※ JDK がインストールされていない環境で利用可
    2. jstack を利用する
	「jstack <pid>」
    3. jcmd Thread.print を利用する
	「jcmd <pid> Thread.print」

    以下はスレッドダンプではないが、スレッドの実行状態が確認できる。
    自身の環境などではこちらのほうが便利。

    4. jconsole を利用する
	JMX を有効にする必要がある。
    5. jvisualvm を利用する
	上記と同様 JMX を有効にする必要がある。

    JMX を有効にする方法。以下のシステムプロパティを指定して JVM を起動する。
	「-Dcom.sun.management.jmxremote=true
        　-Dcom.sun.management.jmxremote.port=7000
          -Dcom.sun.management.jmxremote.ssl=false
          -Dcom.sun.management.jmxremote.authenticate=false」

## スレッドダンプの読み方
    実際のスレッドダンプの出力。
    
    =====
    "my-thread-0" #20 prio=5 os_prio=31 cpu=0.08ms elapsed=9.99s tid=0x00007fe40882e000 nid=0x6003 waiting on condition  [0x0000700011365000]
    java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(java.base@11.0.9/Native Method)
	at com.example.MyThread.run(ThreadDump/ThreadDump.java:30)
    =====

    ・"my-thread-0" : スレッド名
    ・java.lang.Thread.State: TIMED_WAITING : スレッドの状態(この例はSLEEPでの待機中)
    ・ at ... : 現在実行している処理
    
    だいたい上記ぐらいを抑えておけば大丈夫。
    デッドロックの調査はロックを確認する必要があるが、そこは Google 先生におまかせ。。。

    State が取りうる値は以下。
    [Thread.State (Java Platform SE 8 )](https://docs.oracle.com/javase/jp/8/docs/api/java/lang/Thread.State.html)

## どのようなトラブルの調査に利用するのか
    ◆ 調査できる内容
    以下の調査の際に役に立つ。
    ・CPU使用率の高騰
    ・アプリケーションの無応答状態
    ・ある処理が完了しない(無応答のひとつ)
    ・デッドロック(無応答のひとつ)

    1. CPU使用率の高騰について
	スレッドダンプを定期的にとって、長時間 RUNNABLE になっているスレッドがある場合、該当の処理があやしい

    2、3. アプリケーションの無応答、処理が完了しない
	スレッドダンプを定期的にとって、該当の処理が WAITING 状態のままである場合、I/O待ちが疑われる。
	I/O待ちとなっている原因を調査すると原因にたどりつけるかもしれない。
	I/O待ち：データベースの応答待ち、外部サーバの通信応答待ち、ファイルの書き込み/読み込み待ち、入力待ちなど

    4. 複数のスレッド同一のロックオブジェクトを取り合っているか確認する

    ◆ 確認するときの注意点
    スレッドダンプは「その瞬間のプロセスのスレッドの状態」を表したものでしかない。
    「瞬間」がポイントで、その次の瞬間には違う状況になっているかもしれない。
    スレッドダンプでは「あくまでその瞬間、そのプロセスのスレッドの状態はそうだった」しかわからない。
    原因調査では「事象発生時のスレッドの状態遷移」を確認する必要がある。
    このため、事象発生時のスレッドダンプは「定期間隔で複数回」取得してもらう必要がある。

    あと、重要な点として、スレッドダンプはそれをみて解析終了となることはなく、
    あやしいスレッドを特定後、該当スレッドが実行、あるいは、待ちとなっている処理を確認する必要がある。
    このため、基本的に処理のソースコードが読める状態でないと原因にたどり着けない場合が多い。
    ※ ソースが公開されていない製品だと解析が苦しい、ということ。

## jconsole上でスレッドを確認する
    jconsole、jvisualvm を利用するとリアルタイムで JVM のスレッド状態を確認できます。
    自身の環境で再現できているなら、この方法を利用するのが便利。
    ただし、前提として JMX での接続が必要なため、JMX の設定を有効にする必要がある。
